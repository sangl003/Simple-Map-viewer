'''---------------------------------------------------------------------------
 Tool Name:     ImportFromE00
 Source Name:   importe00.py
 Version:       ArcGIS 10.0
 Author:        Environmental Systems Research Institute Inc.
 Required Argumuments:  An input interchange file (.e00)
                        An output directory (where to put the output)
                        An output name (what to call the output)
 Description:   Imports the contents of an ArcInfo interchange file
 Notes: 
 - This script wraps ARCGISHOME/bin/import71.exe
 - The executable only works on Windows with Desktop.
---------------------------------------------------------------------------'''
import arcpy, os, subprocess

#Convert the directory portion of a path string to short filename style
# Note that it is still possible for the name to be too long or to
# have some character in it that is not supported by workstation.
def getShortName(long_path):
    #
    (long_dir, long_name) = os.path.split(long_path)
    for_cmd = 'for %I in ("' + long_dir + '") do echo %~sI'
    p = subprocess.Popen(for_cmd, shell=True, stdout=subprocess.PIPE).stdout
    short_dir = p.readlines()[-1] # last line from for command
    if p.close():
        #This means there was an error calling shell command "for"
        #
        #If the incomming full path is short enough and has no spaces, 
        # and the incoming name is short enough, then we can just use 
        # it, otherwise, we need to throw an error. (max length = 122)
        if (len(long_path)<123) and (long_path.find(" ") == -1) and (len(long_name)<=13):
            return (long_path)
        else:
            #1103 = Error converting directory to short name format
            arcpy.AddIDMessage("Error", 1103)
    short_dir = short_dir.rstrip()
    #Add the unshortened file portion back onto the now-shortened path
    short_path = os.path.join(short_dir, long_name)
    return (short_path)

def expandWorkspace(filepath):
    # If the filepath is not absolute, make it so using the arcpy workspace
    #
    if os.path.isabs(filepath):
        return filepath
    elif arcpy.env.workspace != None:
        return os.path.normpath(os.path.join(arcpy.env.workspace, filepath))
    else:
        return os.path.normpath(os.path.join(os.getcwd(), filepath))

def hasWriteAccess():
    #See if the user has write access to the output directory
    # os.access() isn't giving reliable results, so we have to
    # use this alternate approach
    #
    folderToCreate = arcpy.CreateScratchName("", "", "Folder", dirParam)
    try:
        os.mkdir(folderToCreate)
        os.rmdir(folderToCreate)
        return True
    except:
        return False

# Many errors get caught in tool validation, before execution gets this far.
#  However, some error conditions cannot be caught there because
#  validation should not open the .e00 to find out what it contains.
#
#Try to determine likely causes of errors generated by import71.exe
def checkErrors(errorCode):
    #First check the retval codes
    #
    if errorCode == 1:
        if not hasWriteAccess():
            #No need to check for directory existence.  Framework already did.
            #1250 = User does not have write access to output folder.
            arcpy.AddIDMessage("Error", 1250)
        elif os.path.lexists(outName):
            #12 = <value> already exists
            arcpy.AddIDMessage("Error", 12, outName)
        elif len(outName) > 122:
            #1252 = Full path to output may be too long.
            arcpy.AddIDMessage("Error", 1252)
        elif len(nameParam) > 13:
            #1253 = Output name may be too long.
            arcpy.AddIDMessage("Error", 1253)
        else:
            #856 = An error was encountered while executing <value>.
            arcpy.AddIDMessage("Error", 856, "import71.exe")
    else:
        #So far, I haven't been able to generate any errorCode values
        # other than 1 (tool failed), but just in case...
        #
        #1254 = <value> returned an error code of <value>
        arcpy.AddIDMessage("Error", 1254, "import71.exe", str(errorCode))


def doImport():
    try:
        d = arcpy.GetInstallInfo('desktop')
        import71exe = os.path.join(d['InstallDir'], "bin", "import71.exe")
        # /t indicates to run the .exe in DOS mode.
        retcode = subprocess.call(
                [import71exe, inName, outName, "/t"], shell=True)
    except:
        arcpy.AddIDMessage("Error", 856, "import71")

    if retcode > 0:
        checkErrors(retcode)


#The main block
###############

if not arcpy.GetInstallInfo()['ProductName'] == u'Desktop':
    # Not running from Desktop, generate error
    #
    #1294 = Tool only supported in ArcGIS for Desktop.
    arcpy.AddIDMessage("Error", 1294, "import71")
else:
    # Running from Desktop, process parameters and execute
    inName = getShortName(expandWorkspace(arcpy.GetParameterAsText(0)))
    dirParam = arcpy.GetParameterAsText(1)
    nameParam = arcpy.GetParameterAsText(2)
    outName = getShortName(os.path.join(dirParam, nameParam))
    #
    if os.path.exists(inName):
        doImport()
    else:
        #732 = <value>: Dataset <value> does not exist or is not supported
        arcpy.AddIDMessage("Error", 732, "ImportFromE00", inName)


